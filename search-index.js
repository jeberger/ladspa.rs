var searchIndex = {};
searchIndex['ladspa'] = {"items":[[0,"","ladspa","The ```ladspa``` crate provides an interface for writing [LADSPA](http://www.ladspa.org/)\nplugins safely in Rust.",null,null],[3,"PluginDescriptor","","Describes the properties of a ```Plugin``` to be exposed as a LADSPA plugin.",null,null],[12,"unique_id","","Unique IDs are an unfortunate remnant of the LADSPA API. During development, it is\nsuggested to pick one under 1000, but it should be changed before release. More information\nis available here: http://www.ladspa.org/ladspa_sdk/unique_ids.html",0,null],[12,"label","","Plugin labels are expected to be a unique descriptor string for this specific plugin within\nthe library. Labels are case sensitive and expected not to contain spaces.",0,null],[12,"properties","","The properties of a plugin describe restrictions and features for it's use. See\ndocumentation for ```Properties``` for info on available options.",0,null],[12,"name","","The name of the plugin. This is usually how it is identified.",0,null],[12,"maker","","The maker of the plugin. Can be empty.",0,null],[12,"copyright","","Indicates copyright of the plugin. If no copyright applies, \"None\" should be used.",0,null],[12,"ports","","A vector of input and output ports exposed by the plugin. See the documentation for\n```Port``` for more information.",0,null],[12,"new","","A function which creates a new instance of the plugin.",0,null],[3,"Port","","Represents an input or output to the plugin representing either audio or\ncontrol data.",null,null],[12,"name","","The name of the port. For control ports, this will likely be shown by the host in an\nautomatically generated GUI next to the control. For audio ports, it is mostly just\nfor identification in your code but some hosts may display it.",1,null],[12,"desc","","Describes the type of port: audio or control, input or output.",1,null],[12,"hint","","Most useful on control inputs but can be used on any type of port.",1,null],[12,"default","","Most useful on control inputs but can be used on any type of port.",1,null],[12,"lower_bound","","The lower bound of values to accepted by default (the host may ignore this).",1,null],[12,"upper_bound","","The upper bound of values to accepted by default (the host may ignore this).",1,null],[3,"ControlHint","","Represents the special properties a control port may hold. These are merely hints as to the\nuse of the port and may be completely ignored by the host. For audio ports, use ```CONTROL_HINT_NONE```.\nTo attach multiple properties, bitwise-or them together.\nSee documentation for the constants beginning with HINT_ for the more information.",null,null],[3,"PortConnection","","Represents a connection between a port and the data attached to the port by the plugin\nhost.",null,null],[12,"port","","The port which the data is connected to.",2,null],[12,"data","","The data connected to the port. It's usually simpler to use the various unwrap_* functions\nthan to interface with this directly.",2,null],[3,"Properties","","Represents the special properties a LADSPA plugin can have.\nTo attach multiple properties, bitwise-or them together, for example\n```PROP_REALTIME | PROP_INPLACE_BROKEN```.\nSee documentation for the constants beginning with PROP_ for the more information.",null,null],[4,"PortDescriptor","","Represents the 4 types of ports: audio or control, input or output.",null,null],[13,"Invalid","","",3,null],[13,"AudioInput","","",3,null],[13,"AudioOutput","","",3,null],[13,"ControlInput","","",3,null],[13,"ControlOutput","","",3,null],[4,"DefaultValue","","The default values that a control port may hold. For audio ports, use DefaultControlValue::None.",null,null],[13,"Minimum","","Equal to the ```lower_bound``` of the ```Port```.",4,null],[13,"Low","","For ports with\n```LADSPA_HINT_LOGARITHMIC```, this should be ```exp(log(lower_bound) * 0.75 +\nlog(upper_bound) * 0.25)```. Otherwise, this should be ```(lower_bound * 0.75 +\nupper_bound * 0.25)```.",4,null],[13,"Middle","","For ports with\n```CONTROL_HINT_LOGARITHMIC```, this should be ```exp(log(lower_bound) * 0.5 +\nlog(upper_bound) * 0.5)```. Otherwise, this should be ```(lower_bound * 0.5 +\nupper_bound * 0.5)```.",4,null],[13,"High","","For ports with\n```LADSPA_HINT_LOGARITHMIC```, this should be ```exp(log(lower_bound) * 0.25 +\nlog(upper_bound) * 0.75)```. Otherwise, this should be ```(lower_bound * 0.25 +\nupper_bound * 0.75)```.",4,null],[13,"Maximum","","Equal to the ```upper_bound``` of the ```Port```.",4,null],[13,"Value0","","Equal to 0 or false for toggled values.",4,null],[13,"Value1","","Equal to 1 or true for toggled values.",4,null],[13,"Value100","","Equal to 100.",4,null],[13,"Value440","","Equal to 440, concert A. This may be off by a few Hz if the host is using an alternate\ntuning.",4,null],[4,"PortData","","Represents the four types of data a port can hold.",null,null],[13,"AudioInput","","",5,null],[13,"AudioOutput","","",5,null],[13,"ControlInput","","",5,null],[13,"ControlOutput","","",5,null],[5,"get_ladspa_descriptor","","Your plugin must implement this function.\n```get_ladspa_descriptor``` returns a description of a supported plugin for a given plugin\nindex. When the index is out of bounds for the number of plugins supported by your library,\nyou are expected to return ```None```.",null,null],[6,"Data","","The data type used internally by LADSPA for audio and control ports.",null,null],[17,"HINT_TOGGLED","","Indicates that this is a toggled port. Toggled ports may only have default values\nof zero or one, although the host may send any value, where <= 0 is false and > 0 is true.",null,null],[17,"HINT_SAMPLE_RATE","","Indicates that all values related to the port will be multiplied by the sample rate by\nthe host before passing them to your plugin. This includes the lower and upper bounds. If you\nwant an upper bound of 22050 with this property and a sample rate of 44100, set the upper bound\nto 0.5",null,null],[17,"HINT_LOGARITHMIC","","Indicates that the data passed through this port would be better represented on a\nlogarithmic scale",null,null],[17,"HINT_INTEGER","","Indicates that the data passed through this port should be represented as integers. Bounds\nmay be interpreted exclusively depending on the host",null,null],[17,"PROP_NONE","","No properties.",null,null],[17,"PROP_REALTIME","","Indicates that the plugin has a realtime dependency so it's output may not be cached.",null,null],[17,"PROP_INPLACE_BROKEN","","Indicates that the plugin will not function correctly if the input and output audio\ndata has the same memory location. This could be an issue if you copy input to output\nthen refer back to previous values of the input as they will be overwritten. It is\nrecommended that you avoid using this flag if possible as it can decrease the speed of\nthe plugin.",null,null],[17,"PROP_HARD_REALTIME_CAPABLE","","Indicates that the plugin is capable of running not only in a conventional host but\nalso in a 'hard real-time' environment. To qualify for this the plugin must\nsatisfy all of the following:",null,null],[8,"Plugin","","Represents an instance of a plugin which may be exposed as a LADSPA plugin using\n```get_ladspa_descriptor```. It is not necessary to implement activate to deactivate.",null,null],[11,"activate","","The plugin instance must reset all state information dependent\non the history of the plugin instance here.\nWill be called before `run` is called for the first time.",6,{"inputs":[{"name":"plugin"}],"output":null}],[10,"run","","Runs the plugin on a number of samples, given the connected ports.",6,null],[11,"deactivate","","Indicates the plugin is no longer live.",6,{"inputs":[{"name":"plugin"}],"output":null}],[11,"default","","",1,{"inputs":[{"name":"port"}],"output":{"name":"port"}}],[11,"clone","","",1,{"inputs":[{"name":"port"}],"output":{"name":"port"}}],[11,"clone","","",3,{"inputs":[{"name":"portdescriptor"}],"output":{"name":"portdescriptor"}}],[11,"default","","",3,{"inputs":[{"name":"portdescriptor"}],"output":{"name":"portdescriptor"}}],[11,"hash","","",7,null],[11,"cmp","","",7,{"inputs":[{"name":"controlhint"},{"name":"controlhint"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",7,{"inputs":[{"name":"controlhint"},{"name":"controlhint"}],"output":{"name":"option"}}],[11,"lt","","",7,{"inputs":[{"name":"controlhint"},{"name":"controlhint"}],"output":{"name":"bool"}}],[11,"le","","",7,{"inputs":[{"name":"controlhint"},{"name":"controlhint"}],"output":{"name":"bool"}}],[11,"gt","","",7,{"inputs":[{"name":"controlhint"},{"name":"controlhint"}],"output":{"name":"bool"}}],[11,"ge","","",7,{"inputs":[{"name":"controlhint"},{"name":"controlhint"}],"output":{"name":"bool"}}],[11,"clone","","",7,{"inputs":[{"name":"controlhint"}],"output":{"name":"controlhint"}}],[11,"eq","","",7,{"inputs":[{"name":"controlhint"},{"name":"controlhint"}],"output":{"name":"bool"}}],[11,"ne","","",7,{"inputs":[{"name":"controlhint"},{"name":"controlhint"}],"output":{"name":"bool"}}],[11,"fmt","","",7,{"inputs":[{"name":"controlhint"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"empty","","Returns an empty set of flags.",7,{"inputs":[{"name":"controlhint"}],"output":{"name":"controlhint"}}],[11,"all","","Returns the set containing all flags.",7,{"inputs":[{"name":"controlhint"}],"output":{"name":"controlhint"}}],[11,"bits","","Returns the raw value of the flags currently stored.",7,{"inputs":[{"name":"controlhint"}],"output":{"name":"i32"}}],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",7,{"inputs":[{"name":"controlhint"},{"name":"i32"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",7,{"inputs":[{"name":"controlhint"},{"name":"i32"}],"output":{"name":"controlhint"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",7,{"inputs":[{"name":"controlhint"}],"output":{"name":"bool"}}],[11,"is_all","","Returns `true` if all flags are currently set.",7,{"inputs":[{"name":"controlhint"}],"output":{"name":"bool"}}],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",7,{"inputs":[{"name":"controlhint"},{"name":"controlhint"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",7,{"inputs":[{"name":"controlhint"},{"name":"controlhint"}],"output":{"name":"bool"}}],[11,"insert","","Inserts the specified flags in-place.",7,{"inputs":[{"name":"controlhint"},{"name":"controlhint"}],"output":null}],[11,"remove","","Removes the specified flags in-place.",7,{"inputs":[{"name":"controlhint"},{"name":"controlhint"}],"output":null}],[11,"toggle","","Toggles the specified flags in-place.",7,{"inputs":[{"name":"controlhint"},{"name":"controlhint"}],"output":null}],[11,"bitor","","Returns the union of the two sets of flags.",7,{"inputs":[{"name":"controlhint"},{"name":"controlhint"}],"output":{"name":"controlhint"}}],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",7,{"inputs":[{"name":"controlhint"},{"name":"controlhint"}],"output":{"name":"controlhint"}}],[11,"bitand","","Returns the intersection between the two sets of flags.",7,{"inputs":[{"name":"controlhint"},{"name":"controlhint"}],"output":{"name":"controlhint"}}],[11,"sub","","Returns the set difference of the two sets of flags.",7,{"inputs":[{"name":"controlhint"},{"name":"controlhint"}],"output":{"name":"controlhint"}}],[11,"not","","Returns the complement of this set of flags.",7,{"inputs":[{"name":"controlhint"}],"output":{"name":"controlhint"}}],[11,"from_iter","","",7,{"inputs":[{"name":"controlhint"},{"name":"t"}],"output":{"name":"controlhint"}}],[11,"clone","","",4,{"inputs":[{"name":"defaultvalue"}],"output":{"name":"defaultvalue"}}],[11,"unwrap_audio","","Returns a slice pointing to the internal data of an audio input port. Panics if this port\nis not an ```AudioIn``` port.",2,null],[11,"unwrap_audio_mut","","Returns a mutable slice pointing to the internal data of an audio output port. Panics if\nthis port is not an ```AudioOut``` port.",2,{"inputs":[{"name":"portconnection"}],"output":{"name":"refmut"}}],[11,"unwrap_control","","Returns a refrence to the internal data of an control input port. Panics if this port\nis not an ```ControlIn``` port.",2,{"inputs":[{"name":"portconnection"}],"output":{"name":"data"}}],[11,"unwrap_control_mut","","Returns a mutable refrence to the internal data of an audio output port. Panics if\nthis port is not an ```ControlOut``` port.",2,{"inputs":[{"name":"portconnection"}],"output":{"name":"refmut"}}],[11,"hash","","",8,null],[11,"cmp","","",8,{"inputs":[{"name":"properties"},{"name":"properties"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",8,{"inputs":[{"name":"properties"},{"name":"properties"}],"output":{"name":"option"}}],[11,"lt","","",8,{"inputs":[{"name":"properties"},{"name":"properties"}],"output":{"name":"bool"}}],[11,"le","","",8,{"inputs":[{"name":"properties"},{"name":"properties"}],"output":{"name":"bool"}}],[11,"gt","","",8,{"inputs":[{"name":"properties"},{"name":"properties"}],"output":{"name":"bool"}}],[11,"ge","","",8,{"inputs":[{"name":"properties"},{"name":"properties"}],"output":{"name":"bool"}}],[11,"clone","","",8,{"inputs":[{"name":"properties"}],"output":{"name":"properties"}}],[11,"eq","","",8,{"inputs":[{"name":"properties"},{"name":"properties"}],"output":{"name":"bool"}}],[11,"ne","","",8,{"inputs":[{"name":"properties"},{"name":"properties"}],"output":{"name":"bool"}}],[11,"fmt","","",8,{"inputs":[{"name":"properties"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"empty","","Returns an empty set of flags.",8,{"inputs":[{"name":"properties"}],"output":{"name":"properties"}}],[11,"all","","Returns the set containing all flags.",8,{"inputs":[{"name":"properties"}],"output":{"name":"properties"}}],[11,"bits","","Returns the raw value of the flags currently stored.",8,{"inputs":[{"name":"properties"}],"output":{"name":"i32"}}],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",8,{"inputs":[{"name":"properties"},{"name":"i32"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",8,{"inputs":[{"name":"properties"},{"name":"i32"}],"output":{"name":"properties"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",8,{"inputs":[{"name":"properties"}],"output":{"name":"bool"}}],[11,"is_all","","Returns `true` if all flags are currently set.",8,{"inputs":[{"name":"properties"}],"output":{"name":"bool"}}],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",8,{"inputs":[{"name":"properties"},{"name":"properties"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",8,{"inputs":[{"name":"properties"},{"name":"properties"}],"output":{"name":"bool"}}],[11,"insert","","Inserts the specified flags in-place.",8,{"inputs":[{"name":"properties"},{"name":"properties"}],"output":null}],[11,"remove","","Removes the specified flags in-place.",8,{"inputs":[{"name":"properties"},{"name":"properties"}],"output":null}],[11,"toggle","","Toggles the specified flags in-place.",8,{"inputs":[{"name":"properties"},{"name":"properties"}],"output":null}],[11,"bitor","","Returns the union of the two sets of flags.",8,{"inputs":[{"name":"properties"},{"name":"properties"}],"output":{"name":"properties"}}],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",8,{"inputs":[{"name":"properties"},{"name":"properties"}],"output":{"name":"properties"}}],[11,"bitand","","Returns the intersection between the two sets of flags.",8,{"inputs":[{"name":"properties"},{"name":"properties"}],"output":{"name":"properties"}}],[11,"sub","","Returns the set difference of the two sets of flags.",8,{"inputs":[{"name":"properties"},{"name":"properties"}],"output":{"name":"properties"}}],[11,"not","","Returns the complement of this set of flags.",8,{"inputs":[{"name":"properties"}],"output":{"name":"properties"}}],[11,"from_iter","","",8,{"inputs":[{"name":"properties"},{"name":"t"}],"output":{"name":"properties"}}]],"paths":[[3,"PluginDescriptor"],[3,"Port"],[3,"PortConnection"],[4,"PortDescriptor"],[4,"DefaultValue"],[4,"PortData"],[8,"Plugin"],[3,"ControlHint"],[3,"Properties"]]};
searchIndex['vec_map'] = {"items":[[0,"","vec_map","A simple map based on a vector for small integer keys. Space requirements\nare O(highest integer key).",null,null],[3,"VecMap","","A map optimized for small integer keys.",null,null],[3,"VacantEntry","","A vacant Entry.",null,null],[3,"OccupiedEntry","","An occupied Entry.",null,null],[3,"Iter","","An iterator over the key-value pairs of a map.",null,null],[3,"IterMut","","An iterator over the key-value pairs of a map, with the\nvalues being mutable.",null,null],[3,"Keys","","An iterator over the keys of a map.",null,null],[3,"Values","","An iterator over the values of a map.",null,null],[3,"IntoIter","","A consuming iterator over the key-value pairs of a map.",null,null],[4,"Entry","","A view into a single entry in a map, which may either be vacant or occupied.",null,null],[13,"Vacant","","A vacant Entry",0,null],[13,"Occupied","","An occupied Entry",0,null],[11,"clone","","",1,{"inputs":[{"name":"vecmap"}],"output":{"name":"vecmap"}}],[11,"default","","",1,{"inputs":[{"name":"vecmap"}],"output":{"name":"vecmap"}}],[11,"hash","","",1,{"inputs":[{"name":"vecmap"},{"name":"h"}],"output":null}],[11,"new","","Creates an empty `VecMap`.",1,{"inputs":[{"name":"vecmap"}],"output":{"name":"vecmap"}}],[11,"with_capacity","","Creates an empty `VecMap` with space for at least `capacity`\nelements before resizing.",1,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"vecmap"}}],[11,"capacity","","Returns the number of elements the `VecMap` can hold without\nreallocating.",1,{"inputs":[{"name":"vecmap"}],"output":{"name":"usize"}}],[11,"reserve_len","","Reserves capacity for the given `VecMap` to contain `len` distinct keys.\nIn the case of `VecMap` this means reallocations will not occur as long\nas all inserted keys are less than `len`.",1,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":null}],[11,"reserve_len_exact","","Reserves the minimum capacity for the given `VecMap` to contain `len` distinct keys.\nIn the case of `VecMap` this means reallocations will not occur as long as all inserted\nkeys are less than `len`.",1,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":null}],[11,"keys","","Returns an iterator visiting all keys in ascending order of the keys.\nThe iterator's element type is `usize`.",1,{"inputs":[{"name":"vecmap"}],"output":{"name":"keys"}}],[11,"values","","Returns an iterator visiting all values in ascending order of the keys.\nThe iterator's element type is `&'r V`.",1,{"inputs":[{"name":"vecmap"}],"output":{"name":"values"}}],[11,"iter","","Returns an iterator visiting all key-value pairs in ascending order of the keys.\nThe iterator's element type is `(usize, &'r V)`.",1,{"inputs":[{"name":"vecmap"}],"output":{"name":"iter"}}],[11,"iter_mut","","Returns an iterator visiting all key-value pairs in ascending order of the keys,\nwith mutable references to the values.\nThe iterator's element type is `(usize, &'r mut V)`.",1,{"inputs":[{"name":"vecmap"}],"output":{"name":"itermut"}}],[11,"split_off","","Splits the collection into two at the given key.",1,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"self"}}],[11,"len","","Returns the number of elements in the map.",1,{"inputs":[{"name":"vecmap"}],"output":{"name":"usize"}}],[11,"is_empty","","Returns true if the map contains no elements.",1,{"inputs":[{"name":"vecmap"}],"output":{"name":"bool"}}],[11,"clear","","Clears the map, removing all key-value pairs.",1,{"inputs":[{"name":"vecmap"}],"output":null}],[11,"get","","Returns a reference to the value corresponding to the key.",1,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"option"}}],[11,"contains_key","","Returns true if the map contains a value for the specified key.",1,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"get_mut","","Returns a mutable reference to the value corresponding to the key.",1,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"option"}}],[11,"insert","","Inserts a key-value pair into the map. If the key already had a value\npresent in the map, that value is returned. Otherwise, `None` is returned.",1,{"inputs":[{"name":"vecmap"},{"name":"usize"},{"name":"v"}],"output":{"name":"option"}}],[11,"remove","","Removes a key from the map, returning the value at the key if the key\nwas previously in the map.",1,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"option"}}],[11,"entry","","Gets the given key's corresponding entry in the map for in-place manipulation.",1,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"entry"}}],[11,"or_insert","","Ensures a value is in the entry by inserting the default if empty, and\nreturns a mutable reference to the value in the entry.",0,{"inputs":[{"name":"entry"},{"name":"v"}],"output":{"name":"v"}}],[11,"or_insert_with","","Ensures a value is in the entry by inserting the result of the default\nfunction if empty, and returns a mutable reference to the value in the\nentry.",0,{"inputs":[{"name":"entry"},{"name":"f"}],"output":{"name":"v"}}],[11,"insert","","Sets the value of the entry with the VacantEntry's key,\nand returns a mutable reference to it.",2,{"inputs":[{"name":"vacantentry"},{"name":"v"}],"output":{"name":"v"}}],[11,"get","","Gets a reference to the value in the entry.",3,{"inputs":[{"name":"occupiedentry"}],"output":{"name":"v"}}],[11,"get_mut","","Gets a mutable reference to the value in the entry.",3,{"inputs":[{"name":"occupiedentry"}],"output":{"name":"v"}}],[11,"into_mut","","Converts the entry into a mutable reference to its value.",3,{"inputs":[{"name":"occupiedentry"}],"output":{"name":"v"}}],[11,"insert","","Sets the value of the entry with the OccupiedEntry's key,\nand returns the entry's old value.",3,{"inputs":[{"name":"occupiedentry"},{"name":"v"}],"output":{"name":"v"}}],[11,"remove","","Takes the value of the entry out of the map, and returns it.",3,{"inputs":[{"name":"occupiedentry"}],"output":{"name":"v"}}],[11,"fmt","","",1,{"inputs":[{"name":"vecmap"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from_iter","","",1,{"inputs":[{"name":"vecmap"},{"name":"i"}],"output":{"name":"vecmap"}}],[11,"into_iter","","Returns an iterator visiting all key-value pairs in ascending order of\nthe keys, consuming the original `VecMap`.\nThe iterator's element type is `(usize, &'r V)`.",1,{"inputs":[{"name":"vecmap"}],"output":{"name":"intoiter"}}],[11,"extend","","",1,{"inputs":[{"name":"vecmap"},{"name":"i"}],"output":null}],[11,"extend","","",1,{"inputs":[{"name":"vecmap"},{"name":"i"}],"output":null}],[11,"index","","",1,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"v"}}],[11,"index","","",1,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"v"}}],[11,"index_mut","","",1,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"v"}}],[11,"index_mut","","",1,{"inputs":[{"name":"vecmap"},{"name":"usize"}],"output":{"name":"v"}}],[11,"clone","","",4,{"inputs":[{"name":"iter"}],"output":{"name":"iter"}}],[11,"next","","",4,{"inputs":[{"name":"iter"}],"output":{"name":"option"}}],[11,"size_hint","","",4,null],[11,"next_back","","",4,{"inputs":[{"name":"iter"}],"output":{"name":"option"}}],[11,"next","","",5,{"inputs":[{"name":"itermut"}],"output":{"name":"option"}}],[11,"size_hint","","",5,null],[11,"next_back","","",5,{"inputs":[{"name":"itermut"}],"output":{"name":"option"}}],[11,"clone","","",6,{"inputs":[{"name":"keys"}],"output":{"name":"keys"}}],[11,"clone","","",7,{"inputs":[{"name":"values"}],"output":{"name":"values"}}],[11,"next","","",6,{"inputs":[{"name":"keys"}],"output":{"name":"option"}}],[11,"size_hint","","",6,null],[11,"next_back","","",6,{"inputs":[{"name":"keys"}],"output":{"name":"option"}}],[11,"next","","",7,{"inputs":[{"name":"values"}],"output":{"name":"option"}}],[11,"size_hint","","",7,null],[11,"next_back","","",7,{"inputs":[{"name":"values"}],"output":{"name":"option"}}],[11,"next","","",8,{"inputs":[{"name":"intoiter"}],"output":{"name":"option"}}],[11,"size_hint","","",8,null],[11,"next_back","","",8,{"inputs":[{"name":"intoiter"}],"output":{"name":"option"}}]],"paths":[[4,"Entry"],[3,"VecMap"],[3,"VacantEntry"],[3,"OccupiedEntry"],[3,"Iter"],[3,"IterMut"],[3,"Keys"],[3,"Values"],[3,"IntoIter"]]};
searchIndex['bitflags'] = {"items":[[0,"","bitflags","A typesafe bitmask flag generator.",null,null],[14,"bitflags!","","The `bitflags!` macro generates a `struct` that holds a set of C-style\nbitmask flags. It is useful for creating typesafe wrappers for C APIs.",null,null]],"paths":[]};
initSearch(searchIndex);
